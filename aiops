#!/usr/bin/env python3
"""
AI-RecoverOps CLI Tool
Universal DevOps Automation Platform

Usage:
    aiops init [project-name]           # Initialize new project
    aiops scan [--config file]          # Scan infrastructure for issues
    aiops deploy [--env environment]    # Deploy monitoring and remediation
    aiops monitor [--watch]             # Start monitoring mode
    aiops remediate [incident-id]       # Execute remediation
    aiops config [--list|--set key=val] # Manage configuration
    aiops status                        # Show system status
    aiops version                       # Show version info
"""

import sys
import os
import argparse
import json
import yaml
import subprocess
from pathlib import Path
from datetime import datetime
import requests
import time

class AIOpsCore:
    def __init__(self):
        self.version = "1.0.0"
        self.config_file = Path.cwd() / "aiops.yml"
        self.state_file = Path.cwd() / ".aiops" / "state.json"
        self.config = self.load_config()
        
    def load_config(self):
        """Load configuration from aiops.yml"""
        if self.config_file.exists():
            with open(self.config_file, 'r') as f:
                return yaml.safe_load(f)
        return self.default_config()
    
    def default_config(self):
        """Default configuration template"""
        return {
            'project': {
                'name': 'my-project',
                'version': '1.0.0',
                'description': 'AI-powered DevOps automation'
            },
            'infrastructure': {
                'provider': 'aws',  # aws, azure, gcp, local
                'region': 'us-east-1',
                'services': []
            },
            'monitoring': {
                'enabled': True,
                'interval': 30,
                'log_sources': [],
                'metrics': []
            },
            'remediation': {
                'auto_remediation': True,
                'confidence_threshold': 0.8,
                'max_concurrent': 3,
                'rollback_timeout': 300
            },
            'notifications': {
                'slack': {'enabled': False, 'webhook': ''},
                'email': {'enabled': False, 'smtp': ''},
                'teams': {'enabled': False, 'webhook': ''}
            }
        }
    
    def save_config(self):
        """Save configuration to aiops.yml"""
        with open(self.config_file, 'w') as f:
            yaml.dump(self.config, f, default_flow_style=False, indent=2)
    
    def init_project(self, project_name=None):
        """Initialize new AI-RecoverOps project"""
        if project_name:
            self.config['project']['name'] = project_name
        
        print(f"üöÄ Initializing AI-RecoverOps project: {self.config['project']['name']}")
        
        # Create directory structure
        dirs = [
            '.aiops',
            'configs',
            'playbooks',
            'templates',
            'logs',
            'scripts'
        ]
        
        for dir_name in dirs:
            Path(dir_name).mkdir(exist_ok=True)
            print(f"   Created: {dir_name}/")
        
        # Create configuration files
        self.save_config()
        print(f"   Created: {self.config_file}")
        
        # Create example playbook
        self.create_example_playbook()
        
        # Create example service definition
        self.create_example_service()
        
        print("\n‚úÖ Project initialized successfully!")
        print(f"üìù Edit {self.config_file} to configure your infrastructure")
        print("üéÆ Run 'aiops scan' to start monitoring")
    
    def create_example_playbook(self):
        """Create example remediation playbook"""
        playbook = {
            'name': 'High CPU Remediation',
            'description': 'Automatically handle high CPU usage incidents',
            'triggers': ['high_cpu'],
            'conditions': {
                'confidence': '> 0.8',
                'severity': ['critical', 'high']
            },
            'actions': [
                {
                    'name': 'Check system resources',
                    'type': 'command',
                    'command': 'top -n 1 | head -20',
                    'timeout': 30
                },
                {
                    'name': 'Restart service if needed',
                    'type': 'service',
                    'action': 'restart',
                    'service': '{{ incident.service }}',
                    'condition': 'cpu_usage > 90'
                },
                {
                    'name': 'Scale horizontally',
                    'type': 'scale',
                    'provider': 'aws',
                    'resource': '{{ incident.instance_id }}',
                    'action': 'scale_out',
                    'count': 1
                }
            ],
            'rollback': [
                {
                    'name': 'Scale back if issue resolved',
                    'type': 'scale',
                    'action': 'scale_in',
                    'delay': 300
                }
            ]
        }
        
        playbook_file = Path('playbooks') / 'high_cpu_remediation.yml'
        with open(playbook_file, 'w') as f:
            yaml.dump(playbook, f, default_flow_style=False, indent=2)
        print(f"   Created: {playbook_file}")
    
    def create_example_service(self):
        """Create example service definition"""
        service = {
            'name': 'web-server',
            'type': 'web_application',
            'provider': 'aws',
            'resources': {
                'instances': ['i-1234567890abcdef0'],
                'load_balancer': 'alb-web-server',
                'auto_scaling_group': 'asg-web-server'
            },
            'monitoring': {
                'metrics': ['cpu_usage', 'memory_usage', 'response_time'],
                'logs': ['/var/log/nginx/access.log', '/var/log/app.log'],
                'health_check': 'http://localhost:8080/health'
            },
            'thresholds': {
                'cpu_usage': {'warning': 70, 'critical': 90},
                'memory_usage': {'warning': 80, 'critical': 95},
                'response_time': {'warning': 1000, 'critical': 5000}
            }
        }
        
        service_file = Path('configs') / 'web-server.yml'
        with open(service_file, 'w') as f:
            yaml.dump(service, f, default_flow_style=False, indent=2)
        print(f"   Created: {service_file}")
    
    def scan_infrastructure(self):
        """Scan infrastructure for potential issues"""
        print("üîç Scanning infrastructure...")
        
        # Load service configurations
        services = self.load_services()
        
        issues = []
        for service in services:
            print(f"   Scanning: {service['name']}")
            service_issues = self.scan_service(service)
            issues.extend(service_issues)
        
        if issues:
            print(f"\n‚ö†Ô∏è  Found {len(issues)} potential issues:")
            for issue in issues:
                print(f"   - {issue['severity']}: {issue['description']}")
        else:
            print("\n‚úÖ No issues detected")
        
        return issues
    
    def load_services(self):
        """Load all service configurations"""
        services = []
        config_dir = Path('configs')
        
        if config_dir.exists():
            for config_file in config_dir.glob('*.yml'):
                with open(config_file, 'r') as f:
                    service = yaml.safe_load(f)
                    services.append(service)
        
        return services
    
    def scan_service(self, service):
        """Scan individual service for issues"""
        issues = []
        
        # Check if service is reachable
        if 'health_check' in service.get('monitoring', {}):
            try:
                response = requests.get(service['monitoring']['health_check'], timeout=5)
                if response.status_code != 200:
                    issues.append({
                        'service': service['name'],
                        'severity': 'high',
                        'description': f"Health check failed: HTTP {response.status_code}"
                    })
            except Exception as e:
                issues.append({
                    'service': service['name'],
                    'severity': 'critical',
                    'description': f"Service unreachable: {str(e)}"
                })
        
        # Check resource utilization (mock for demo)
        import random
        cpu_usage = random.randint(20, 95)
        memory_usage = random.randint(30, 90)
        
        thresholds = service.get('thresholds', {})
        
        if cpu_usage > thresholds.get('cpu_usage', {}).get('critical', 90):
            issues.append({
                'service': service['name'],
                'severity': 'critical',
                'description': f"High CPU usage: {cpu_usage}%"
            })
        elif cpu_usage > thresholds.get('cpu_usage', {}).get('warning', 70):
            issues.append({
                'service': service['name'],
                'severity': 'warning',
                'description': f"Elevated CPU usage: {cpu_usage}%"
            })
        
        return issues
    
    def deploy_monitoring(self, environment='production'):
        """Deploy monitoring and remediation infrastructure"""
        print(f"üöÄ Deploying AI-RecoverOps to {environment}...")
        
        # Start API server
        print("   Starting API server...")
        api_process = subprocess.Popen([
            sys.executable, 'api/main.py'
        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        time.sleep(3)  # Wait for API to start
        
        # Test API connection
        try:
            response = requests.get('http://localhost:8000/health', timeout=5)
            if response.status_code == 200:
                print("   ‚úÖ API server started successfully")
            else:
                print("   ‚ùå API server failed to start")
                return False
        except:
            print("   ‚ùå API server not responding")
            return False
        
        # Start dashboard (optional)
        if self.config.get('dashboard', {}).get('enabled', True):
            print("   Starting dashboard...")
            try:
                subprocess.Popen([
                    'npm', 'start'
                ], cwd='dashboard', stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                print("   ‚úÖ Dashboard starting on http://localhost:3000")
            except:
                print("   ‚ö†Ô∏è  Dashboard failed to start (optional)")
        
        print("\n‚úÖ Deployment completed!")
        print("üìä Dashboard: http://localhost:3000")
        print("üîß API: http://localhost:8000")
        
        return True
    
    def start_monitoring(self, watch=False):
        """Start monitoring mode"""
        print("üëÅÔ∏è  Starting monitoring mode...")
        
        if watch:
            print("   Watching for changes... (Press Ctrl+C to stop)")
            try:
                while True:
                    issues = self.scan_infrastructure()
                    if issues:
                        self.handle_incidents(issues)
                    time.sleep(self.config['monitoring']['interval'])
            except KeyboardInterrupt:
                print("\n   Monitoring stopped")
        else:
            issues = self.scan_infrastructure()
            if issues:
                self.handle_incidents(issues)
    
    def handle_incidents(self, issues):
        """Handle detected incidents"""
        for issue in issues:
            if issue['severity'] in ['critical', 'high']:
                print(f"üö® Handling {issue['severity']} incident: {issue['description']}")
                
                if self.config['remediation']['auto_remediation']:
                    self.execute_remediation(issue)
    
    def execute_remediation(self, issue):
        """Execute remediation for an issue"""
        print(f"üîß Executing remediation for: {issue['description']}")
        
        # Load appropriate playbook
        playbooks = self.load_playbooks()
        
        for playbook in playbooks:
            if self.matches_playbook(issue, playbook):
                print(f"   Using playbook: {playbook['name']}")
                self.run_playbook(playbook, issue)
                break
        else:
            print("   No matching playbook found")
    
    def load_playbooks(self):
        """Load all remediation playbooks"""
        playbooks = []
        playbook_dir = Path('playbooks')
        
        if playbook_dir.exists():
            for playbook_file in playbook_dir.glob('*.yml'):
                with open(playbook_file, 'r') as f:
                    playbook = yaml.safe_load(f)
                    playbooks.append(playbook)
        
        return playbooks
    
    def matches_playbook(self, issue, playbook):
        """Check if issue matches playbook triggers"""
        # Simple matching logic - can be enhanced
        triggers = playbook.get('triggers', [])
        
        for trigger in triggers:
            if trigger.lower() in issue['description'].lower():
                return True
        
        return False
    
    def run_playbook(self, playbook, issue):
        """Execute playbook actions"""
        actions = playbook.get('actions', [])
        
        for action in actions:
            print(f"     Executing: {action['name']}")
            
            if action['type'] == 'command':
                self.run_command(action, issue)
            elif action['type'] == 'service':
                self.manage_service(action, issue)
            elif action['type'] == 'scale':
                self.scale_resource(action, issue)
    
    def run_command(self, action, issue):
        """Run shell command"""
        command = action['command']
        timeout = action.get('timeout', 30)
        
        try:
            result = subprocess.run(
                command, shell=True, timeout=timeout,
                capture_output=True, text=True
            )
            if result.returncode == 0:
                print(f"       ‚úÖ Command executed successfully")
            else:
                print(f"       ‚ùå Command failed: {result.stderr}")
        except subprocess.TimeoutExpired:
            print(f"       ‚è∞ Command timed out after {timeout}s")
    
    def manage_service(self, action, issue):
        """Manage system service"""
        service_action = action['action']  # restart, stop, start
        service_name = action.get('service', issue.get('service', 'unknown'))
        
        print(f"       {service_action.title()}ing service: {service_name}")
        # Implementation would depend on the system (systemctl, docker, etc.)
    
    def scale_resource(self, action, issue):
        """Scale cloud resources"""
        provider = action.get('provider', 'aws')
        scale_action = action['action']  # scale_out, scale_in
        
        print(f"       Scaling {scale_action} on {provider}")
        # Implementation would use cloud provider APIs
    
    def show_status(self):
        """Show system status"""
        print("üìä AI-RecoverOps Status")
        print("=" * 40)
        
        # Check API status
        try:
            response = requests.get('http://localhost:8000/health', timeout=5)
            if response.status_code == 200:
                print("üîß API Server: ‚úÖ Running")
                data = response.json()
                print(f"   Uptime: {data.get('uptime', 'Unknown')}")
                print(f"   Models: {len(data.get('models_loaded', []))}")
            else:
                print("üîß API Server: ‚ùå Error")
        except:
            print("üîß API Server: ‚ùå Not running")
        
        # Check dashboard status
        try:
            response = requests.get('http://localhost:3000', timeout=5)
            if response.status_code == 200:
                print("üìä Dashboard: ‚úÖ Running")
            else:
                print("üìä Dashboard: ‚ùå Error")
        except:
            print("üìä Dashboard: ‚ùå Not running")
        
        # Show configuration
        print(f"\nüìù Project: {self.config['project']['name']}")
        print(f"üèóÔ∏è  Provider: {self.config['infrastructure']['provider']}")
        print(f"ü§ñ Auto-remediation: {'‚úÖ' if self.config['remediation']['auto_remediation'] else '‚ùå'}")
        
        # Show services
        services = self.load_services()
        print(f"üîç Services monitored: {len(services)}")
        for service in services:
            print(f"   - {service['name']} ({service.get('type', 'unknown')})")

def main():
    parser = argparse.ArgumentParser(
        description='AI-RecoverOps - Universal DevOps Automation Platform',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Init command
    init_parser = subparsers.add_parser('init', help='Initialize new project')
    init_parser.add_argument('project_name', nargs='?', help='Project name')
    
    # Scan command
    scan_parser = subparsers.add_parser('scan', help='Scan infrastructure')
    scan_parser.add_argument('--config', help='Configuration file')
    
    # Deploy command
    deploy_parser = subparsers.add_parser('deploy', help='Deploy monitoring')
    deploy_parser.add_argument('--env', default='production', help='Environment')
    
    # Monitor command
    monitor_parser = subparsers.add_parser('monitor', help='Start monitoring')
    monitor_parser.add_argument('--watch', action='store_true', help='Continuous monitoring')
    
    # Remediate command
    remediate_parser = subparsers.add_parser('remediate', help='Execute remediation')
    remediate_parser.add_argument('incident_id', help='Incident ID')
    
    # Config command
    config_parser = subparsers.add_parser('config', help='Manage configuration')
    config_parser.add_argument('--list', action='store_true', help='List configuration')
    config_parser.add_argument('--set', help='Set configuration key=value')
    
    # Status command
    subparsers.add_parser('status', help='Show system status')
    
    # Version command
    subparsers.add_parser('version', help='Show version')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    aiops = AIOpsCore()
    
    try:
        if args.command == 'init':
            aiops.init_project(args.project_name)
        elif args.command == 'scan':
            aiops.scan_infrastructure()
        elif args.command == 'deploy':
            aiops.deploy_monitoring(args.env)
        elif args.command == 'monitor':
            aiops.start_monitoring(args.watch)
        elif args.command == 'remediate':
            print(f"Executing remediation for incident: {args.incident_id}")
        elif args.command == 'config':
            if args.list:
                print(yaml.dump(aiops.config, default_flow_style=False))
            elif args.set:
                key, value = args.set.split('=', 1)
                print(f"Setting {key} = {value}")
        elif args.command == 'status':
            aiops.show_status()
        elif args.command == 'version':
            print(f"AI-RecoverOps v{aiops.version}")
    
    except KeyboardInterrupt:
        print("\n\nüëã Operation cancelled")
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()